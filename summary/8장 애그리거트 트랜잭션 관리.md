# 8장: 애그리거트 트랜잭션 관리

### 1장. 애그리거트와 트랜잭션

- 동일한 식별자를 사용하며 동일한 상태를 갖는 애그리거트를 각기 다른 객체에서 수정한다면 어떻게 될까?
    - 애그리거트가 주문 객체라고 가정하고 운영자가 배송지 주소를 수정하는 사이, 고객이 배송지 주소를 수정했다고 가정해보자.
    - 결과적으론 고객이 수정한 주소는 운영자의 수정에 덮어씌워져 반영되지 못할 것이다. 이는 애그리거트의 일관성을 훼손하는 결과다. 우린 어떻게 대처해야 할까?
        - 운영자가 조회 이후 수정을 진행하는 동안, 고객이 애그리거트를 수정하지 못하게 막을 수 있다.
        - 혹은 운영자가 조회를 시작한 뒤 언제라도 고객이 수정한다면, 기존 절차를 리셋하고 다시 조회하여 수정하게도 할 수 있다.
    - 이를 해결하기 위해선 트랜잭션 처리 기법이 필요하다. 대표적으로는 **선점(Perssimistic) 잠금과 비선점(Optimisitic) 잠금**이 존재한다. 살펴보자.

---

### 2장. 선점 잠금

- 선점 잠금은 애그리거트를 조회해서 동작을 수행하려는 스레드가 해당 작업, 애그리거트를 핸들링하는 작업이 끝날 때까지 다른 어떠한 스레드도 애그리거트를 수정하지 못하게 금지하는 방식이다.
    - 먼저 애그리거트를 차지한 스레드가 트랜잭션을 커밋하고 나면 그제서야 잠금이 해제된다. 이를 통해 데이터가 덮어 씌워지는 등 의도치 않은 데이터 충돌 문제를 해결할 수 있다.
    - 일반적으로 데이터베이스 레벨에서 지원하는 로우 단위 잠금을 사용한다.
        - `select for update`
        - JPA EntityManager에서는 `LockModeType.PESSIMISTIC_WRITE` 를 활용해 적용 가능하다. 데이터베이스 레벨에서는 `for update` 쿼리가 나간다.
        - 스프링 데이터 JPA에서는 `@Lock` 애노테이션을 사용할 수 있다.
- 선점 잠금은 잠금 순서에 따라 데드락이 발생할 가능성이 존재한다.
    1. 스레드1이 A 애그리거트에 대해서 선점 잠금을 획득한다. 
        
        → T1(A)
        
    2. 스레드2는 B 애그리거트에 대해서 선점 잠금을 획득한다. 
        
        → T1(A), T2(B)
        
    3. 스레드1이 B 애그리거트를 사용하기 위해 선점 잠금을 시도한다.
        
        → T1(A, B_), T2(B)
        
    4. 스레드2는 A 애그리거트를 사용하기 위해 선점 잠금을 시도한다.
        
        → T1(A, B_), T2(B, A_)
        
        - 이 경우 스레드1은 A 애그리거트에 대한 잠금을 획득한 채로 B를 획득하려하고, 스레드2는 B 애그리거트에 대한 잠금을 획득한 채로 A를 획득하려고 시도하는 교착 상태가 발생한다.
    - 잠금을 **획득하는 시도에 최대 대기 시간을 지정**하면 위 문제가 해소된다.
        - 스프링 데이터 JPA에서는 `@QueryHints` 애노테이션을 사용해 쿼리 힌트로 대기 시간을 지정할 수 있다.
        - DBMS에 따라 힌트가 적용되지 않을 수도 있습니다.

---

### 3장. 비선점 잠금

- 항상 선점 잠금 방식이 해답이 되진 않습니다. 아래 예시를 보시죠.
    1. 운영자가 주문 정보를 조회합니다. 목적은 배송 상태를 변경하기 위함입니다.
    2. 고객은 배송지를 변경하기 위해서 변경 폼을 요청하고 배송지를 변경합니다.
    3. 이 후 운영자는 2번의 과정동안 특정 일을 진행하다가, 배송 상태를 변경합니다.
    - 이 경우라면 운영자가 다시 고객이 배송지를 변경했음에도 1번에서 조회한 배송지로 그대로 배송을 하게 된다. 즉 고객이 변경한 배송지가 반영되지 않은 것이다.
    - 이 땐 동시에 접근하는 것은 금지하는 것이 아니라, **변경된 데이터를 DBMS에 실제로 반영할 때 변경 가능 여부를 확인**하는 비선점 방식이 유효하다.
- 비선점 잠금 방식은 버전을 통해 구현한다.
    1. 스레드 1이 애그리거트를 조회해온 타이밍의 버전이 5다.
    2. 스레드 2 역시 조회한 버전은 5다.
    3. 스레드 1이 먼저 트랜잭션을 커밋하면 이 때 버전은 5에서 1을 더한 6이 된다.
    4. 스레드 2가 2번에서 조회한 버전은 5이며, 변경을 시도할 때 UPDATE 쿼리는 버전이 5인 로우라는 조건문이 추가된다. 이 때 5인 버전은 이미 존재하지 않으므로 데이터 수정에 실패한다.
        
        ```sql
        UPDATE USERS SET delivery_status = 'COMPLETE', version = version + 1
        WHERE version = 5;
        ```
        
    - JPA에서는 `@Version` 애노테이션으로 버전을 지원한다.
- 이러한 비선점 잠금 방식에서 쿼리의 수행 결과가 0이라면 수정된 로우가 없다는 것을 의미한다. 이 땐 트랜잭션 종료 시점에 `OptimisticLockingFailureException` 예외가 발생한다.
- 특정 A 회원의 시점에선 최초 수정 폼을 전달할 때 버전 정보를 함께 전달하며, 서버쪽으로 변경 요청을 전송할 때도 버전 정보를 담아 요청한다. 요청을 받은 서버에선 해당 애그리거트를 다시 조회해 회원에게 전달받은 버전과 일치하는지를 재판단해 이후 로직을 지정한다.
    - 만약 달라졌다면 다른 스레드가 그 사이 이미 수정한 것이므로 수정 실패를 반환한다.
        - 이 때 스프링 프레임워크에서 반환하는 `OptimisticLockingFailureException` 는 응용 서비스 계층에서까진 버전이 달라지지 않았지만, 조회 이후의 찰나의 순간에 변경됐다는 것을 의미한다.
        - 반면 임의로 비즈니스 실패를 반환한 경우는 수정 폼으로 버전을 전달한 순간부터 조회 직전까지의 기간 내에서 변경된 것을 의미한다.
    - 둘을 구분하면 애그리거트의 수정이 실패한 시점을 보다 정확하게 알 수 있다.
- 애그리거트 루트가 아닌 밸류 객체가 달라지더라도 위 비선점 잠금 방식은 동일하게 유지되어야 한다. JPA는 이를 위해 `find` 시점에 강제로 버전값을 증가시킬 수 있는 `LockModeType.OPTIMISTIC_FORCE_INCREMENT` 를 지원한다.