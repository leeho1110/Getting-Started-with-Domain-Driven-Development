# 8장: 애그리거트 트랜잭션 관리

### 1장. 애그리거트와 트랜잭션

- 동일한 식별자를 사용하며 동일한 상태를 갖는 애그리거트를 각기 다른 객체에서 수정한다면 어떻게 될까?
    - 애그리거트가 주문 객체라고 가정하고 운영자가 배송지 주소를 수정하는 사이, 고객이 배송지 주소를 수정했다고 가정해보자.
    - 결과적으론 고객이 수정한 주소는 운영자의 수정에 덮어씌워져 반영되지 못할 것이다. 이는 애그리거트의 일관성을 훼손하는 결과다. 우린 어떻게 대처해야 할까?
        - 운영자가 조회 이후 수정을 진행하는 동안, 고객이 애그리거트를 수정하지 못하게 막을 수 있다.
        - 혹은 운영자가 조회를 시작한 뒤 언제라도 고객이 수정한다면, 기존 절차를 리셋하고 다시 조회하여 수정하게도 할 수 있다.
    - 이를 해결하기 위해선 트랜잭션 처리 기법이 필요하다. 대표적으로는 **선점(Perssimistic) 잠금과 비선점(Optimisitic) 잠금**이 존재한다. 살펴보자.

---

### 2장. 선점 잠금

- 선점 잠금은 애그리거트를 조회해서 동작을 수행하려는 스레드가 해당 작업, 애그리거트를 핸들링하는 작업이 끝날 때까지 다른 어떠한 스레드도 애그리거트를 수정하지 못하게 금지하는 방식이다.
    - 먼저 애그리거트를 차지한 스레드가 트랜잭션을 커밋하고 나면 그제서야 잠금이 해제된다. 이를 통해 데이터가 덮어 씌워지는 등 의도치 않은 데이터 충돌 문제를 해결할 수 있다.
    - 일반적으로 데이터베이스 레벨에서 지원하는 로우 단위 잠금을 사용한다.
        - `select for update`
        - JPA EntityManager에서는 `LockModeType.PESSIMISTIC_WRITE` 를 활용해 적용 가능하다. 데이터베이스 레벨에서는 `for update` 쿼리가 나간다.
        - 스프링 데이터 JPA에서는 `@Lock` 애노테이션을 사용할 수 있다.
- 선점 잠금은 잠금 순서에 따라 데드락이 발생할 가능성이 존재한다.
    1. 스레드1이 A 애그리거트에 대해서 선점 잠금을 획득한다. 
        
        → T1(A)
        
    2. 스레드2는 B 애그리거트에 대해서 선점 잠금을 획득한다. 
        
        → T1(A), T2(B)
        
    3. 스레드1이 B 애그리거트를 사용하기 위해 선점 잠금을 시도한다.
        
        → T1(A, B_), T2(B)
        
    4. 스레드2는 A 애그리거트를 사용하기 위해 선점 잠금을 시도한다.
        
        → T1(A, B_), T2(B, A_)
        
        - 이 경우 스레드1은 A 애그리거트에 대한 잠금을 획득한 채로 B를 획득하려하고, 스레드2는 B 애그리거트에 대한 잠금을 획득한 채로 A를 획득하려고 시도하는 교착 상태가 발생한다.
    - 잠금을 **획득하는 시도에 최대 대기 시간을 지정**하면 위 문제가 해소된다.
        - 스프링 데이터 JPA에서는 `@QueryHints` 애노테이션을 사용해 쿼리 힌트로 대기 시간을 지정할 수 있다.
        - DBMS에 따라 힌트가 적용되지 않을 수도 있습니다.

---