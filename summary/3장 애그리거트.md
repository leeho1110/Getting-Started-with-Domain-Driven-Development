# 3장: 애그리거트

### 1. 애그리거트

- 우리가 실무에서 접하는 도메인 모델은 복잡하다. 이 때 상위 도메인 모델 수준에서 복잡함을 보다 이해하기 쉽고 관리하기 편하게 만들기 위해선 특정 단위로 묶어 관리하는 것이 좋다. 이를 **애그리거트**라고 한다.
    - 애그리거트 단위로 도메인 모델을 관리하면 이해하기 쉽다는 장점 외에도 일관성을 관리할 수 있다.
    - 도메인 모델은 반드시 하나의 애그리거트에 포함된다. 따라서 도메인 규칙이나 요구사항에 따라 각 애그리거트들의 경계를 정해 도메인 모델을 분류해야 한다.
        - 만약 2개의 도메인 모델이 변경될 때 서로에게 영향을 주지 않는다면, 이 둘은 다른 애그리거트에 속해야 한다.
        - 저자는 애그리거트를 생성할 때 최초엔 커보이지만, 도메인 지식이 늘어날수록 줄어든다고 말한다. 저자의 경험으론 일반적으로 애그리거트와 엔티티 객체가 1:1 형태로 구성되는 경우가 많다고 한다.
- 애그리거트는 관련된 도메인 모델을 하나로 묶은 단위라고 했다. 따라서 애그리거트 내부의 도메인 모델은 대부분 유사하거나 동일한 라이프 사이클을 갖게 된다.

---

### 2. 애그리거트 루트

- 애그리거트는 여러 도메인 모델이 하나로 묶인 군집이다. 따라서 도메인 규칙에 따라 기능이 실행될 때 애그리거트에 속한 모든 객체들은 **반드시 정상 상태**를 가져야 한다. 이 때 **모든 객체들을 일관된 정상 상태로 유지시킬 책임**을 갖는 객체가 바로 **애그리거트의 루트 엔티티**이다. 애그리거트 루트라고도 한다.
    - 이 때 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경해선 안된다. 이는 애그리거트 루트가 적용하는 규칙에서 벗어나 애그리거트의 내부 일관성을 깨뜨리는 원인 중 하나다.
        - 이를 지키기 위해서 도메인 모델은 단순한 필드 변경을 수행하는 **set 메서드는 `public` 접근 제어자로 만들지 않고,** **밸류는 불변 객체로 구현**해야 한다.
        - 자바 빈즈 규약에 따라 습관적으로 만드는 `getter`, `setter` 에서 `setter` 는 반드시 피하는 것이 좋다. 만약 필드 변경이 필요하다면 의미가 드러나는 이름을 사용하자.
- 서비스를 구현하며 중요한 것 중 하나는 트랜잭션이다. 일반적인 경우 트랜잭션 범위는 작은 것이 좋다.
    - 수정해야할 테이블이 늘어나면 그만큼 얻어야 하는 락의 범위가 커진다. 이는 접근할 수 있는 트랜잭션 개수의 감소를 의미하므로 자연스럽게 성능이 하락한다.
    - 하나의 트랜잭션에선 하나의 애그리거트만 수정해야한다.
    - 만약 하나의 트랜잭션에서 여러 개의 애그리거트를 수정해야한다면 응용 서비스에서 트랜잭션을 설정해 수정하도록 구현하자. 혹은 도메인 이벤트를 활용할 수 있다.

---

### 3. 리포지터리와 애그리거트

- 앞서 리포지터리의 역할은 도메인 모델의 영속성을 처리하는 것임을 확인했다. 애그리거트는 **개념상 완전한 형태를 갖는 하나의 도메인 모델을 표현**하므로 애그리거트 단위로 묶을 수 있기도 하다. 자연스럽게 리포지터리도 애그리거트 단위로 존재한다.
    - 리포지터리는 애그리거트를 영속화하고, 사용하기 위해 읽어야 하므로 저장, 조회 메서드가 필요하다.
        - `save()`
        - `findBy*()`

---

### 4. ID를 이용한 애그리거트 참조

- ORM을 사용하게 되면 애그리거트 내 엔티티 객체를 로딩하는 것이 굉장히 편리해진다. 그만큼 필드에 존재하는 다른 애그리거트에 접근하기도 쉬워진다. 편리함을 핑계로 다른 애그리거트에 직접 접근해 수정하지 말자. 이는 애그리거트의 결합도를 높혀 변경에 민감한 설계를 만들어낸다.
    - 필드에 객체 참조가 아닌 ID 참조를 사용하면 위 문제를 손쉽게 해결할 수 있다.
    - 하지만 그만한 부작용도 있다. ID 참조를 통한 지연 로딩에서는 최초 모든 데이터를 가져오는 것이 아닌 해당 ID를 갖는 객체가 필요할 때만 조회 쿼리가 발생한다.
    - 이 때 ID가 여러 개라면, **최초 시점의 1개**의 쿼리와 **해당 ID들을 조회하기 위해 ID 개수(N)**의 조회 쿼리가 발생하는데, 이를 **N+1 조회 문제**라고 부른다.
    - 처음부터 조인을 활용해 1개의 쿼리로 가져오면 문제를 해결할 수 있다.
        - `fetch join`
    - 하지만 만약 애그리거트마다 영속성이 저장된 곳이 다르다면 조인으로 해결이 불가능하다. 이런 경우에는 조회 전용 리포지토리를 통해 처리할 수 있다.

---

### 5. 애그리거트 간 집합 연관

- 본문에선 상품-카테고리의 연관 관계를 예시로 설명한다. 상품은 하나의 카테고리를 가지기 때문에 N-1 관계를 갖는다. 반대로 하나의 카테고리는 여러 개의 상품을 가질 수 있으므로 1-N 관계를 갖는다. 그렇다면 이걸 반드시 코드에 반영해야할까?
    - 우리는 과연 하나의 카테고리에 포함된 모든 상품을 가져올 일이 있을까? 아마 대부분의 상황에선 상품 리스트를 노출하고 추가적으로 카테고리를 노출하는 형태를 띌 것이다.
    - 우리에게 1-N(카테고리-상품) 관계를 카테고리 객체에 구현할 이유는 없다. 우린 상품-카테고리의 N:1 단방향 관계만 구현하면 요구사항을 만족시킬 수 있다.
        - 만약 구현한다면 카테고리 조회마다 N개의 상품을 불러오느라 성능이 급격하게 하락할 것이다.
- M:N, 다대다 관계는 조인 테이블을 통해 표현한다.
    - `@ElementCollection`
    - `@CollectionTable`

---