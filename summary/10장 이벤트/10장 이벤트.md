# 10장: 이벤트

### 1. 시스템 간 강결합 문제

- 쇼핑몰에서 구매를 취소하고 환불을 진행하는 프로세스를 예로 들어보자.
    - 환불 기능은 주문 도메인 엔티티가 처리해도 크게 이상하지 않다.
    - 따라서 환불 기능을 제공하는 도메인 서비스를 파라미터 혹은 인스턴스 필드로 전달받아 해당 도메인 서비스를 실행하면 환불 절차가 완료된다.
        - 환불은 내부 절차 외에 외부 PG사에게도 요청을 전송해야 한다.
    - 그렇다면 여기서 외부 PG사가 정상적이지 않다면 내부 절차는 어떻게 처리해야할까? **외부 결제 시스템 연동과 내부 로직을 하나의 트랜잭션**으로 묶어야 하는 걸까?
        - 만약 내부 시스템 예외라면 트랜잭션을 롤백하는 것이 맞지만 내부는 정상적으로 처리되고 외부 시스템과의 연동만 실패한다면, 내부 트랜잭션은 커밋하고 외부 시스템은 추후 재요청하는 방식으로 처리할수도 있지 않을까?
    - 외부 시스템의 응답이 늦는다면 응답 대기 시간동안 주문 취소 기능은 응답이 완료될 때까지 대기해야 한다. 이는 애플리케이션이 **외부 시스템 성능에 영향을 받는다는 것**을 의미한다.
    - 또한 ‘주문 취소’ 기능은 `Order`, `OrderService` 같은 도메인 서비스 혹은 도메인 객체에 구현될텐데 환불에 관련된 기능까지 섞여버리는 문제도 생긴다.
        - 만약 환불 이후 고객에게 통지까지 해야된다면? 점점 더 복잡해지고 트랜잭션 처리도 어려워진다. 심지어 이 경우 처리가 완료될 때까지 필요한 외부 시스템까지 2개로 늘어난다.
- 위에서 생기는 문제의 근본적인 원인은 바로 **주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트의 강결합**이다.
    - 이런 강결합을 제거하기 위한 방법이 바로 (비동기) 이벤트다.

---

### 2. 이벤트

- 여기서 이벤트는 ‘과거에 벌어진 어떤 사건’ 을 의미한다.
    - 사용자의 암호 변경, 사용자의 주문 취소, 모두 ‘암호 변경 이벤트’, ‘주문 취소 이벤트’의 발생으로 볼 수 있다.
    - 도메인 모델에서도 사용자의 어떤 행동으로 인해 상태가 변경되는 일을 이벤트로 표현할 수 있다.
- 도메인 모델에 이벤트를 도입하기 위해선 총 4가지의 구성요소가 필요하다. 이벤트, 이벤트 생성 주체, 이벤트 디스패처(이벤트 퍼블리셔), 이벤트 핸들러(이벤트 구독자).
    
    <img src="img/Untitled.png">
    
    - 이벤트 생성 주체 → 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체를 의미한다. **도메인 로직을 실행하던 중 상태가 변경된다면 관련 이벤트를 발생**시킨다.
    - 이벤트 핸들러 → 생성 주체에서 생성시킨 이벤트에 반응한다. 이벤트에는 관련 데이터가 담겨있는데, 이를 활용해 특정 기능을 실행한다.
        - ‘주문 취소됨 이벤트’ 를 수신하는 이벤트 핸들러라면 주문자에게 SMS로 주문 취소 사실을 통지하는 기능을 실행할 수 있다.
    - 이벤트 디스패처 → 그림을 살펴보면 이벤트를 발생시키는 ‘이벤트 생성 주체’와 이벤트를 통해 특정 기능을 실행하는 ‘이벤트 핸들러’를 이어주는 역할이 존재한다. 이것이 바로 이벤트 디스패처(퍼블리셔)다. 디스패처는 **이벤트를 전달받고, 처리 가능한 핸들러에게 이벤트를 전파**시킨다.
        - 디스패처의 구현 방식에 따라 이벤트 생성 및 처리를 동기 혹은 비동기로 실행한다.
- 이벤트의 용도는 크게 두 가지다. 첫 번째는 트리거다. 도메인 상태가 변경될 때 후처리가 필요한 경우, 이를 위한 트리거로 이벤트를 사용할 수 있다. 아까 주문 취소의 예시가 바로 이 예시다.
    - 이를 통해 주문을 취소하는 도메인 로직과 취소 결과를 통보하는 **도메인 로직이 섞여 강결합되는 것을 방지**할 수 있다.
    - 추가적인 후처리가 필요하다면 이벤트 핸들러만 추가하면 된다. 도메인 로직이 점점 두꺼워지고 복잡해지는 것을 방지할 수 있으며, 주문 취소 로직을 건드릴 필요도 없다.

---

### 3. 이벤트, 핸들러, 디스패처 구현

- 이벤트는 별도로 이를 위한 상위 타입이 존재하진 않는다. 일반적으로 상태 변화를 과거 시제로, 클래스명의 접미사로 `Event` 를 사용하는 정도로 충분하다.
    - 이벤트 클래스에선 반드시 이벤트를 핸들링하기 위한 최소 데이터를 포함해야 된다. 주문 취소 이벤트라면 주문 식별자 번호가 포함된다.
    - 공통 프로퍼티가 있다면 관련 상위 클래스를 만들어 중복 필드 구현을 피할 수도 있다.
- 스프링 프레임워크에선 이벤트 발생과 퍼블리싱을 위해 `ApplicationEventPublisher`를 사용한다.
    - 이벤트는 `ApplicationEventPublisher` 타입이 제공하는 `publishEvent(..)` 메서드를 통해 발생이 가능하다.
    - 이를 처리하는 핸들러는 `@EventLister(xx.class)` 어노테이션을 통해 명시할 수 있다.

---

### 4. 동기 이벤트 처리 문제

- 이벤트 리스너를 통해 강결합 문제는 해결했지만, 아직 문제는 남아있다. 바로 외부 시스템이다. 아마 결제라면 PG사 정도가 되겠다.
    - 이 때 외부 시스템 기능이 느려지면 이벤트 핸들러의 성능은 여지없이 느려진다. 심지어 트랜잭션으로 묶여있다면 어떻게 해야할까?
- 외부 시스템과의 연동을 동기로 처리하면 이와 같은 성능와 트랜잭션 범위 문제가 발생한다. 이는 이벤트를 비동기로 처리하거나, 이벤트와 트랜잭션을 연계해 처리할 수 있다.

---

### 5. 비동기 이벤트 처리

- 관점을 바꿔보자.
    - 주문이 취소된 시점에 반드시 결제 취소가 이뤄져야 할까? 조금 늦게 결제가 취소되면 안되는 걸까? 주문은 조금 예민한 문제니 회원가입으로 바꿔보자.
    - 회원가입을 완료하면 메일을 통해 회원가입 결과를 통지한다. 이 때 메일이 발송되는 시점이 반드시 회원가입 완료와 정확하게 동일해야할까? 10초, 20초, 조금 넘어선 1분 정도 지연되면 안되는 걸까?
    - 주문 취소와 결제 취소, 회원가입과 메일 통보, 모두 후처리가 완벽하게 보장된다면 괜찮을 수 있다. 이는 물론 특정 기능의 성격이므로 모든 기능 구현을 위와 같이 일반화해서는 안된다.
- 즉 우린 구현 상에 있어서 ‘A 이후 B가 실행된다’ 에서 ‘A 이후, 최대 언제까지 B가 실행된다’ 라는 성격을 갖는 기능을 마주할 때가 많다.
    - 위와 같은 특정 시점 내에 후처리가 완벽하게 수행된다는 결과만 보장할 수 있다면 A와 B의 실행을 비동기로 처리해도 괜찮다. 이 경우 이벤트를 비동기로 처리할 수 있다.
    
    > *다시 말해서 A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.*
    > 
- 이벤트를 비동기로 구현하는 방법은 다양하다. 이 중 몇 가지를 꼽자면 아래와 같다.
    - 로컬 핸들러를 비동기로 실행하기
        - 스프링이 제공하는 `@EnableAsync` , `@Async` 애노테이션을 활용하면 비동기로 이벤트 핸들러를 실행시킬 수 있다.
        - 스프링 부트 애플리케이션에 `@EnableAsync` , 이벤트 핸들러에 `@Async` 를 붙이면 비동기 형태로 이벤트 발생과 핸들링을 별도 스레드가 처리한다.
    - 메시지 큐를 사용하기
        - RabbitMQ, Kafka와 같은 메시징 시스템을 활용할 수 있다. 처리 프로세스는 아래와 같다.
            
                <img src="img/Untitled 1.png">
            
        - 메시지 큐를 사용할 때 주의사항은 이벤트 발생 주체와 이벤트 핸들러가 별도 프로세스에 동작한다는 점이다. 또한 글로벌 트랜잭션 문제도 존재한다.
    - 이벤트 저장소와 이벤트 포워더 사용하기
    - 이벤트 저장소와 이벤트 제공 API 사용하기

---